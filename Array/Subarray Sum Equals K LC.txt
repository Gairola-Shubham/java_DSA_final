class Solution {
    // sliding window approach only positive numbers 
    public int subarraySum3(int[] nums, int k) {
        int n = nums.length;
        int right = 0;
        int left = 0;
        int sum  = nums[0];
        int cnt = 0;
        while(right<n){
            while(left<=right && sum>k){
                sum -= nums[left];
                left++;
            }
            if(sum==k) cnt++;
            right++;
            if(right<n) sum += nums[right];
        }
        return cnt;
    }
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSumFreq = new HashMap<>();
        prefixSumFreq.put(0, 1); // Initialize with sum 0

        int sum = 0;
        int count = 0;

        for (int num : nums) {
            sum += num;

            // Check if there is a prefix sum that would make current subarray sum to k
            if (prefixSumFreq.containsKey(sum - k)) {
                count += prefixSumFreq.get(sum - k);
            }

            // Update prefix sum frequency
            prefixSumFreq.put(sum, prefixSumFreq.getOrDefault(sum, 0) + 1);
        }

        return count;
    }
    public int subarraySum1(int[] nums, int k) {
        int n = nums.length;
        int cnt = 0;
        for(int i=0; i<n; i++){
            int sum = 0;
            for(int j=i; j<n; j++){
                sum +=nums[j];
                if(sum==k) cnt++;
            }
        }
        return cnt;
    
    }
}